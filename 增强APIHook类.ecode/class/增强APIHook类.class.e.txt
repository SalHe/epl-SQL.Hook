.版本 2

.程序集 增强APIHook类, , 公开, 利用dtcser的"易语言取汇编指令长度模块源码"增强了一下,可以自动判断头部代码长度,可无需停止Hook直接调用,可以多级JmpHook.
.程序集变量 OldFuncAddr, 整数型, , , 原始函数内存地址(不管修改没修改,都是这个)
.程序集变量 OldHeadCode, 字节集, , , 原始函数头的原始代码(长度最少5个,会自动检测这个长度,针对一些多个字节的函数头,自动检测选择>5的首个符合条件的长度备份)
.程序集变量 OldProtect, 整数型, , , 原始保护属性
.程序集变量 NewFuncAddr, 整数型, , , 新过程,被Hook之后跳转到的过程代码起始地址(如果要变更为C方式调用,可+28然后patch一下),其实这个没多大用处
.程序集变量 NewFuncHead, 整数型, , , 新生成的函数头地址,无需停用即可调用,不会漏掉Hook,Hook卸载时,可选是否保留生成的函数头(清除函数头,本地址会变为0)
.程序集变量 NewHeadCode, 字节集, , , 新生成的函数头的代码,长度最小为10(5+5跳过来5个,跳回去5个)
.程序集变量 isCdecl, 逻辑型, , , 是否被当成C调用方式处理过,以便还原(其实不要的话应该也不要紧,因为没人会去调用Hook之后的函数吧?)
.程序集变量 JmpCode, 字节集, , , 跳转代码,5个字节,Jmp xxxx 跳到新过程,不管函数头几个字节,这5个是固定的.暂停与继续用到这个
.程序集变量 被保存的头部大小, 整数型, , , 函数头被备份的头部长度,最少5个字节
.程序集变量 被暂停的句柄, 整数型, , "0", 被暂停的线程句柄,以便恢复,这个变量应该不会导致安全隐患(类中的全局变量本身是相对与其他类对立的,再者就是活动线程只有1个)

.子程序 _初始化, , , 当基于本类的对象被创建后,此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前,此方法会被自动调用
    isCdecl ＝ 假
    连续赋值 (0, OldFuncAddr, OldProtect, NewFuncAddr, NewFuncHead, 被保存的头部大小)
    连续赋值 ({ }, OldHeadCode, NewHeadCode, JmpCode)
    ' 本源码来自易语言资源网(www.eyuyan.la)
    清除数组 (被暂停的句柄)

.子程序 检测是否已被Hook, 整数型, 公开, 检测前5个字节是否被JmpHook(是否为Jmp xxxxxxxx).返回0未Hook,返回1已Hook,返回2被自身Hook
    .参数 DllName, 文本型, , 模块名称,必填,以便在安装Hook之前检测.
    .参数 FuncName, 文本型, , 函数名称,必填,以便在安装Hook之前检测.注意:务必区分大小写,否则会找不到函数
    .局部变量 theFuncAddr, 整数型

    theFuncAddr ＝ API_GetProcAddress (API_LoadLibraryA (DllName), FuncName)
    .如果真 (有效句柄 (theFuncAddr))
        .如果真 (指针到字节集 (theFuncAddr, 1) ＝ { 233 } 且 sizeofcode (theFuncAddr) ＝ 5) ' 第一字节是E9（Jmp） ' JmpHook都是5个字节
            .如果真 (OldFuncAddr ＝ theFuncAddr)
                .如果真 (取字节集数据 (指针到字节集 (OldFuncAddr ＋ 1, 4), #整数型, ) ＋ 5 ＋ theFuncAddr ＝ NewFuncAddr)
                    返回 (2)
                .如果真结束
                
            .如果真结束
            返回 (1)
        .如果真结束
        
    .如果真结束
    返回 (0)

.子程序 安装HookByName, 逻辑型, 公开, 根据函数名称安装Hook,成功真,失败假.参数4默认真(是否立即启动);参数5默认假(C方式调用);参数6默认假(多级Jmp)
    .参数 DllName, 文本型, , 模块名称
    .参数 FuncName, 文本型, , 函数名称.注意:务必区分大小写,否则会找不到函数
    .参数 NewProc, 整数型, , 新函数过程地址*指针
    .参数 StartAtOnce, 逻辑型, 可空, 默认真,是否立即Hook
    .参数 __Cdecl, 逻辑型, 可空, 默认假,真为__cdecl调用
    .参数 MultiJmp, 逻辑型, 可空, 默认假,多级Jmp方式Hook,为真的时候才判断前5个字节中的第一个是不是E9,但是别人的Hook可能会破坏你的Hook!(如果别人的Hook是传统的暂停再继续,也就是说反复还原代码再修改代码,那就没辙了)
    .局部变量 theFuncAddr, 整数型

    theFuncAddr ＝ API_GetProcAddress (API_LoadLibraryA (DllName), FuncName)
    .如果 (有效句柄 (theFuncAddr))
        返回 (安装HookByAddr (theFuncAddr, NewProc, StartAtOnce, __Cdecl, MultiJmp))
    .否则
        返回 (假)
    .如果结束
    

.子程序 安装HookByAddr, 逻辑型, 公开, 根据函数地址安装Hook,成功真,失败假.参数3默认真(是否立即启动);参数4默认假(C方式调用);参数5默认假(多级Jmp)
    .参数 FunctionAddr, 整数型, , 原始函数地址*指针
    .参数 NewProc, 整数型, , 新函数过程地址*指针
    .参数 StartAtOnce, 逻辑型, 可空, 默认真,是否立即Hook
    .参数 __cdecl, 逻辑型, 可空, 默认假,真为__cdecl调用
    .参数 MultiJmp, 逻辑型, 可空, 同 安装HookByName 解释
    .局部变量 Int, 整数型
    .局部变量 指针, 整数型
    .局部变量 代码, 整数型
    .局部变量 old, 整数型
    .局部变量 tempcode, 整数型
    .局部变量 头部临时大小, 整数型
    .局部变量 头部临时位置, 整数型
    .局部变量 temp被写到内存地址, 整数型
    .局部变量 temp被修正的地址, 整数型
    .局部变量 i, 整数型
    .局部变量 发现call的头长度位置, 整数型
    .局部变量 call的原始地址, 整数型

    .如果真 (有效句柄 (FunctionAddr) ＝ 假)
        返回 (假)
    .如果真结束
    .如果真 (OldFuncAddr ＝ FunctionAddr) ' 防止同一个Hook(同名的Hook)被重复安装,导致混乱
        返回 (真) ' 返回真,表示安装成功
    .如果真结束
    OldFuncAddr ＝ FunctionAddr
    ' 判断函数头长度,至少5个字节才够Jmp Hook 的,并且保证新生成的函数头正常使用,不会破坏代码的完整性.
    头部临时位置 ＝ OldFuncAddr
    头部临时大小 ＝ sizeofcode (头部临时位置) ' 如果等于或大于5,就直接备份这个长度,比如6个字节的函数头
    被保存的头部大小 ＝ 头部临时大小
    .判断循环首 (被保存的头部大小 ＜ 5) ' 刚进入函数第一行不可能就是call xxxx的形式，顶多是已经被hook变成Jmp xxxxx的形式，所以第一次不用判断出了Jmp的代码，第二行之后再判断
        头部临时位置 ＝ 头部临时位置 ＋ 头部临时大小
        头部临时大小 ＝ sizeofcode (头部临时位置)
        .如果真 (头部临时大小 ＝ 5)
            .判断开始 (指针到字节集 (头部临时位置, 1) ＝ { 232 }) ' call
                发现call的头长度位置 ＝ 被保存的头部大小
                call的原始地址 ＝ 头部临时位置 ＋ 5 ＋ 取字节集数据 (指针到字节集 (头部临时位置 ＋ 1, 4), #整数型, )
            .默认
                
            .判断结束
            
        .如果真结束
        被保存的头部大小 ＝ 被保存的头部大小 ＋ 头部临时大小
    .判断循环尾 ()
    .如果真 (被保存的头部大小 ＜ 5)
        被保存的头部大小 ＝ 0
        OldHeadCode ＝ { }
        返回 (假)
    .如果真结束
    ' 下面更改保护属性,长度还是根据检测出来的长度
    .如果真 (API_VirtualProtect (OldFuncAddr, 被保存的头部大小, 64, OldProtect) ＝ 0) ' 属性改写失败,Hook不会成功
        OldHeadCode ＝ { }
        连续赋值 (0, OldFuncAddr, OldProtect)
        返回 (假)
    .如果真结束
    ' 新处理过程
    NewFuncAddr ＝ NewProc
    ' 判断第一个字节是不是Jmp,即是否已经被Hook
    OldHeadCode ＝ 指针到字节集 (OldFuncAddr, 被保存的头部大小)
    .如果 (指针到字节集 (OldFuncAddr, 1) ＝ { 233 } 且 MultiJmp 且 sizeofcode (OldFuncAddr) ＝ 5) ' 仅针对函数头第一个字节,这里其实可以根据需要判断第一个字节,因为我不知道还有没有jnz等等方式的Hook,自己拓展去吧(其实可以加一个方法,用于指定判断的条件,不过这样的东西,应该很少用到的吧？)
        ' 这里既然前面5个字节中第一个字节已经是Jmp了,说明被Hook了,所以只按照常规方法处理前5个字节即可
        tempcode ＝ 取字节集数据 (指针到字节集 (OldFuncAddr ＋ 1, 4), #整数型, ) ' 原始的跳到的位置的机器码
        tempcode ＝ OldFuncAddr ＋ 5 ＋ tempcode ' 原始跳到的内存地址
        NewHeadCode ＝ 取空白字节集 (10)
        NewHeadCode ＝ { 233, 0, 0, 0, 0 }
        NewFuncHead ＝ API_lstrcpynA_字节集 (NewHeadCode, NewHeadCode, 0)
        tempcode ＝ tempcode － 5 － NewFuncHead ' 计算应该跳到的新的位置的机器码,保护原来的Hook
        写到内存 (到整数 (tempcode), NewFuncHead ＋ 1, 4)
    .否则
        ' 生成新的函数头
        NewHeadCode ＝ 取空白字节集 (被保存的头部大小 ＋ 5) ' 跳回来的Jmp,就是5个字节
        NewHeadCode ＝ OldHeadCode ＋ { 233, 0, 0, 0, 0 }
        NewFuncHead ＝ API_lstrcpynA_字节集 (NewHeadCode, NewHeadCode, 0)
        ' =============判断头部是否包含call，计算出call后面的地址，并补丁
        .判断开始 (发现call的头长度位置 ≠ 0)
            temp被写到内存地址 ＝ NewFuncHead ＋ 发现call的头长度位置 ＋ 1 ' 后面+1是因为共5字节,最后四个才是要写入的地址
            temp被修正的地址 ＝ call的原始地址 － 4 － temp被写到内存地址 ' -5+1=-4
            写到内存 (到整数 (temp被修正的地址), temp被写到内存地址, 4)
            ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -在内存位置:” ＋ 到文本 (temp被写到内存地址) ＋ “ -修正包含的call机器码地址(OD中的机器码):” ＋ 到文本 (temp被修正的地址))
        .默认
            
        .判断结束
        ' =============
        ' ===下面写入并补丁跳回地址
        temp被写到内存地址 ＝ NewFuncHead ＋ 被保存的头部大小 ＋ 1 ' 后面+1是因为共5字节,最后四个才是要写入的地址
        temp被修正的地址 ＝ OldFuncAddr ＋ 被保存的头部大小 － (NewFuncHead ＋ 被保存的头部大小 ＋ 5) ' 这个逻辑我怎么也看不懂了
        写到内存 (到整数 (temp被修正的地址), temp被写到内存地址, 4)
    .如果结束
    ' 输出调试文本 (“APIHook增强类-> 新函数头生成完毕!下面将判断C方式调用”)
    ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -新函数头生成完毕!下面将判断C方式调用”)
    ' 强制修改为__cdecl方式调用
    .如果真 (__cdecl)
        指针 ＝ NewProc ＋ 28 ' 与我最早接触C调用的平栈方式相同,后来看到云外归鸟的代码才知道,这个易语言子程序call固定长度28
        API_RtlMoveMemory_读取整数 (代码, 指针, 1) ' 实际读取的是单个字节
        .如果真 (代码 ＝ 194) ' 为 ret 000x
            代码 ＝ 195 ' 为 ret
            .如果真 (API_VirtualProtect (指针, 1, 64, old) ≠ 0)
                API_RtlMoveMemory_写入整数 (指针, 代码, 1) ' 修改为ret
                isCdecl ＝ 真 ' 标记为是被按照C方式处理了,以便以后还原
                API_VirtualProtect (指针, 1, old, old)
                ' 输出调试文本 (“APIHook增强类-> 新过程被强制为C方式调用”)
                ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -新过程被强制为C方式调用”)
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    ' 修改原始函数头,Jmp到新过程地址
    Int ＝ NewProc － OldFuncAddr － 5 ' Hook还按照通常处理方式,仅处理前5个字节(剩下的字节填充nop!),Hook中跳回来的时候,返回到被保存的头部下一句,而不是固定的第6个字节
    JmpCode ＝ { 233 } ＋ 到字节集 (Int) ＋ 写出Nop数量 ()
    .如果真 (是否为空 (StartAtOnce))
        StartAtOnce ＝ 真
    .如果真结束
    .如果真 (StartAtOnce)
        ' 输出调试文本 (“APIHook增强类-> 函数头生成完毕!下面将暂停其他线程!”)
        ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -函数头生成完毕!下面将暂停其他线程!”)
        暂停其他线程 ()
        ' 输出调试文本 (“APIHook增强类-> 其他线程已经被挂起!下面将写入Hook!”)
        ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -其他线程已经被挂起!下面将写入Hook!”)
        写到内存 (JmpCode, OldFuncAddr, 被保存的头部大小) ' 安装Hook后,并没有还原内存属性,方便暂停以及继续Hook,提高效率
        ' 输出调试文本 (“APIHook增强类-> 写入Hook完毕!下面将恢复被挂起的线程!”)
        ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -写入Hook完毕!下面将恢复被挂起的线程!”)
        恢复其他线程 ()
        ' 输出调试文本 (“APIHook增强类-> 被挂起的线程恢复完毕!请查看线程状态!”)
        ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -被挂起的线程恢复完毕!请查看线程状态!”)
    .如果真结束
    ' 调试输出文本 (“APIHook增强类-> 被Hook的地址:” ＋ 到文本 (FunctionAddr) ＋ “ -处理完成!”)
    返回 (真)

.子程序 卸载Hook, 逻辑型, 公开, 如果是被强制作为C调用,可选择是否恢复,默认恢复.注意:为了直接调用返回值,卸载成功返回假,失败返回真!!!
    .参数 完全卸载, 逻辑型, 可空, 默认真,清理生成的函数头信息
    .参数 恢复调用, 逻辑型, 可空, 默认真,恢复原来的__stdcall方式调用,必须在Hook时指定强制C方式并且成功修改为C方式才有效
    .局部变量 指针, 整数型
    .局部变量 代码, 整数型
    .局部变量 old, 整数型

    .如果真 (OldFuncAddr ≠ 0)
        .如果真 (API_VirtualProtect (OldFuncAddr, 被保存的头部大小, 64, old) ≠ 0)
            暂停其他线程 ()
            写到内存 (OldHeadCode, OldFuncAddr, 被保存的头部大小)
            恢复其他线程 ()
            API_VirtualProtect (OldFuncAddr, 被保存的头部大小, OldProtect, 0)
            .如果真 (是否为空 (恢复调用))
                恢复调用 ＝ 真
            .如果真结束
            .如果真 (恢复调用 且 isCdecl)
                指针 ＝ NewFuncAddr ＋ 28
                API_RtlMoveMemory_读取整数 (代码, 指针, 1)
                .如果真 (代码 ＝ 195) ' 为 ret
                    代码 ＝ 194 ' 为 ret 000x
                    .如果真 (API_VirtualProtect (指针, 1, 64, old) ≠ 0)
                        API_RtlMoveMemory_写入整数 (指针, 代码, 1) ' 修改为ret,这里直接写就行,其他线程应该不会调用这个吧？
                        isCdecl ＝ 假
                        API_VirtualProtect (指针, 1, old, old)
                    .如果真结束
                    
                .如果真结束
                
            .如果真结束
            .如果真 (是否为空 (完全卸载))
                完全卸载 ＝ 真
            .如果真结束
            .如果 (完全卸载)
                连续赋值 ({ }, OldHeadCode, NewHeadCode, JmpCode)
                连续赋值 (0, OldFuncAddr, OldProtect, NewFuncAddr, NewFuncHead, 被保存的头部大小)
            .否则
                连续赋值 (0, OldFuncAddr, OldProtect) ' NewFuncAddr, NewFuncHead, 被保存的头部大小 被保留以便继续使用
            .如果结束
            返回 (假)
        .如果真结束
        
    .如果真结束
    返回 (真)

.子程序 继续Hook, 逻辑型, 公开, 传统的继续/开始Hook,成功返回真,失败返回假.若Hook被卸载,返回假
    .如果真 (OldFuncAddr ≠ 0)
        暂停其他线程 ()
        写到内存 (JmpCode, OldFuncAddr, 被保存的头部大小)
        恢复其他线程 ()
        
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 暂停Hook, 逻辑型, 公开, 传统的暂停/还原Hook,成功返回真,失败返回假.并不还原C方式调用的代码以及内存属性等
    .如果真 (OldFuncAddr ≠ 0)
        暂停其他线程 ()
        写到内存 (OldHeadCode, OldFuncAddr, 被保存的头部大小)
        恢复其他线程 ()
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 函数原内存地址, 整数型, 公开, 返回函数原始的位置.注意:该方法的返回值只有当Hook被暂停后才可以调用,否则调用将导致死循环
    返回 (OldFuncAddr)

.子程序 函数新过程地址, 整数型, 公开, 返回函数被Hook之后跳到的新过程地址,外部实际上就知道.没多大用处,删掉也罢
    返回 (NewFuncAddr)

.子程序 新函数头, 整数型, 公开, 返回新生成的函数头部地址,无需暂停Hook即可调用,可防止漏掉Hook,并且不会造成死循环.Hook卸载后,若不清除函数头,则可继续使用
    返回 (NewFuncHead)

.子程序 清理新函数头, 逻辑型, 公开, 清理新函数头之前必须先卸载Hook,否则不会生效!成功返回真,否则假
    .如果真 (OldFuncAddr ＝ 0) ' 卸载之后 OldFuncAddr ＝ 0 ,否则表示没卸载
        连续赋值 ({ }, OldHeadCode, NewHeadCode, JmpCode)
        连续赋值 (0, OldFuncAddr, OldProtect, NewFuncAddr, NewFuncHead, 被保存的头部大小)
        返回 (真) ' 本源码来自易语言资源网(www.eyuyan.la)
    .如果真结束
    返回 (假)

.子程序 调用原函数, 整数型, 公开, 失败返回0.自动选择被调用地址,若新函数头生成失败,自动选择原始地址调用.可直接无缝调用原函数(支持_CDECL和_stdcall),参数必须都为整数型,非整数型请自行取址.
    .参数 参数1, 整数型, 可空
    .参数 参数2, 整数型, 可空
    .参数 参数3, 整数型, 可空
    .参数 参数4, 整数型, 可空
    .参数 参数5, 整数型, 可空
    .参数 参数6, 整数型, 可空
    .参数 参数7, 整数型, 可空
    .参数 参数8, 整数型, 可空
    .参数 参数9, 整数型, 可空
    .参数 参数10, 整数型, 可空
    .参数 参数11, 整数型, 可空
    .参数 参数12, 整数型, 可空
    .参数 参数13, 整数型, 可空
    .参数 参数14, 整数型, 可空
    .参数 参数15, 整数型, 可空
    .局部变量 被调用地址, 整数型
    .局部变量 ret, 整数型

    被调用地址 ＝ NewFuncHead
    .如果真 (NewFuncHead ＝ 0)
        被调用地址 ＝ OldFuncAddr
    .如果真结束
    .如果真 (被调用地址 ≠ 0)
        汇编动态调用 (被调用地址, , ret, 参数1, 参数2, 参数3, 参数4, 参数5, 参数6, 参数7, 参数8, 参数9, 参数10, 参数11, 参数12, 参数13, 参数14, 参数15)
    .如果真结束
    返回 (ret)

.子程序 写出Nop数量, 字节集, , 当函数头大于5个字节时,多余的以nop填充,防止破坏代码,我也不知道有没有这个必要
    .局部变量 bin, 字节集
    .局部变量 循环次数, 整数型
    .局部变量 i, 整数型

    循环次数 ＝ 被保存的头部大小 － 5
    .如果真 (循环次数 ≥ 1)
        .计次循环首 (循环次数, i)
            bin ＝ bin ＋ { 144 }
        .计次循环尾 ()
    .如果真结束
    返回 (bin)

.子程序 汇编动态调用, 整数型, , 动态调用各种函数.可以为_CDECL和_stdcall,忘了是哪位大神的手笔了...修改了一下,终于可以封装在类内部了(但是不确定有没有问题)
    .参数 地址, 整数型, , 可以为_CDECL和_stdcall,该子程序已经被修改,请勿移动至类外,否则无法正常使用!!!
    .参数 缓存区1, 整数型, 参考 可空, 一定要为参考,无需输入,为缓冲区(用来备份堆栈,以方便平衡栈)
    .参数 缓存区或返回值, 整数型, 参考 可空, 一定要为参考,无需输入,为缓冲区(用来备份EAX,以方便返回内容,如果在此处填写变量地址则改变量会变为调用子程序的返回值)
    .参数 参数1, 整数型, 可空
    .参数 参数2, 整数型, 可空
    .参数 参数3, 整数型, 可空
    .参数 参数4, 整数型, 可空
    .参数 参数5, 整数型, 可空
    .参数 参数6, 整数型, 可空
    .参数 参数7, 整数型, 可空
    .参数 参数8, 整数型, 可空
    .参数 参数9, 整数型, 可空
    .参数 参数10, 整数型, 可空
    .参数 参数11, 整数型, 可空
    .参数 参数12, 整数型, 可空
    .参数 参数13, 整数型, 可空
    .参数 参数14, 整数型, 可空
    .参数 参数15, 整数型, 可空

    置入代码 ({ 137, 101, 248, 86, 81, 51, 201, 81, 198, 193, 15, 139, 245, 129, 198, 160, 0, 0, 0, 131, 238, 4, 131, 238, 8, 139, 198, 139, 0, 133, 192, 116, 8, 139, 70, 252, 80, 131, 69, 244, 4, 226, 235, 199, 192, 0, 0, 0, 0, 255, 85, 12, 144, 144, 144, 144, 144, 144, 144, 144, 139, 216, 139, 141, 24, 0, 0, 0, 137, 1, 139, 195, 41, 165, 248, 255, 255, 255, 3, 165, 248, 255, 255, 255, 201, 195 })
    ' 修改的地方可以自行对比,具体原理自己分析吧 = =!我不是高手,我的理解不一定正确,自己看着办吧
    返回 (1)

.子程序 读取一字节, 字节型, , sizeofcode中用的,上面的都没用这个
    .参数 addr, 整数型
    .局部变量 ret, 整数型

    API_RtlMoveMemory_读取整数 (ret, addr, 1)
    返回 (到字节 (ret))

.子程序 sizeofcode, 整数型, , 返回当前地址所指的汇编指令的长度.注意代码对齐,在OD中的地址不能断开.参考自dtcser的"易语言取汇编指令长度模块源码".非常好的源码,不过貌似只能用于32位的系统上,如果dtcser见到,还望指点一二...
    .参数 address, 整数型, , 指令地址(十进制整数)
    .局部变量 table_1, 字节集
    .局部变量 table_2, 字节集
    .局部变量 opcode, 字节型
    .局部变量 p, 整数型
    .局部变量 tempopcode, 字节型
    .局部变量 instruction, 字节型
    .局部变量 size, 整数型
    .局部变量 opsizeprefix, 整数型
    .局部变量 addressprefix, 整数型

    .局部变量 modrm, 字节型
    .局部变量 sib, 字节型

    table_1 ＝ { 2, 2, 2, 2, 4, 16, 1, 1, 2, 2, 2, 2, 4, 16, 1, 64, 2, 2, 2, 2, 4, 16, 1, 1, 2, 2, 2, 2, 4, 16, 1, 1, 2, 2, 2, 2, 4, 16, 32, 1, 2, 2, 2, 2, 4, 16, 32, 1, 2, 2, 2, 2, 4, 16, 32, 1, 2, 2, 2, 2, 4, 16, 32, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 32, 32, 32, 32, 16, 18, 4, 6, 1, 1, 1, 1, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 6, 18, 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 24, 1, 1, 1, 1, 1, 16, 16, 16, 16, 1, 1, 1, 1, 4, 16, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 6, 6, 8, 1, 2, 2, 6, 18, 12, 1, 8, 1, 1, 4, 1, 1, 2, 2, 2, 2, 4, 4, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 132, 132, 132, 132, 4, 4, 4, 4, 144, 144, 24, 4, 1, 1, 1, 1, 32, 1, 32, 32, 1, 1, 6, 18, 1, 1, 1, 1, 1, 1, 2, 2 }
    table_2 ＝ { 2, 2, 2, 2, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 6, 2, 0, 0, 1, 1, 1, 2, 6, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 6, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    p ＝ address
    opcode ＝ 读取一字节 (p)
    .判断循环首 (table_1 [opcode ＋ 1] ＝ 32) ' #C_PREFIX
        .如果真 (opcode ＝ 102) ' #C_66
            opsizeprefix ＝ 1
        .如果真结束
        .如果真 (opcode ＝ 103) ' #C_67
            addressprefix ＝ 1
        .如果真结束
        size ＝ size ＋ 1
        p ＝ p ＋ 1
        opcode ＝ 读取一字节 (p)
    .判断循环尾 ()
    instruction ＝ table_1 [opcode ＋ 1]
    .如果真 (opcode ＝ 246 或 opcode ＝ 247)
        opcode ＝ 读取一字节 (p ＋ 1)
        .如果真 (位与 (opcode, 56) ≠ 0)
            instruction ＝ 2 ' #C_MODRM
        .如果真结束
        
    .如果真结束
    .如果真 (opsizeprefix ≠ 0)
        .如果真 (位与 (instruction, 16) ≠ 0) ' #C_DATA32
            instruction ＝ 位与 (instruction, 位取反 (16)) ' #C_DATA32
            instruction ＝ 位或 (instruction, 8) ' #C_DATA16
        .如果真结束
        ' 本源码来自易语言资源网(www.eyuyan.la)
    .如果真结束
    .如果真 (addressprefix ≠ 0 且 位与 (instruction, 128) ＝ 0) ' #C_REL
        instruction ＝ 位与 (instruction, 位取反 (16)) ' #C_DATA32
        instruction ＝ 位与 (instruction, 位取反 (4)) ' #C_DATA8
        instruction ＝ 位或 (instruction, 8) ' #C_DATA16
    .如果真结束
    .如果真 (位与 (instruction, 128) ≠ 0) ' #C_REL
        instruction ＝ 位与 (instruction, 位取反 (128)) ' #C_REL
    .如果真结束
    .如果真 (instruction ＝ 64) ' #C_2BYTE
        size ＝ size ＋ 1
        p ＝ p ＋ 1
        instruction ＝ table_2 [读取一字节 (p) ＋ 1]
    .如果真结束
    size ＝ size ＋ 1
    .如果真 (位与 (instruction, 2) ≠ 0) ' #C_MODRM
        size ＝ size ＋ 1
        p ＝ p ＋ 1
        modrm ＝ 读取一字节 (p)
        .如果真 (右移 (modrm, 6) ＝ 0 且 位与 (modrm, 7) ＝ 5)
            size ＝ size ＋ 4
        .如果真结束
        .如果真 (右移 (modrm, 6) ≠ 3 且 位与 (modrm, 7) ＝ 4)
            size ＝ size ＋ 1
            p ＝ p ＋ 1
            sib ＝ 读取一字节 (p)
            .如果真 (右移 (modrm, 6) ＝ 1 且 位与 (modrm, 7) ＝ 4)
                size ＝ size ＋ 1
            .如果真结束
            .如果真 (右移 (modrm, 6) ＝ 2 且 位与 (modrm, 7) ＝ 4)
                size ＝ size ＋ 4
            .如果真结束
            .如果真 (右移 (modrm, 6) ＝ 0 且 位与 (sib, 7) ＝ 5)
                size ＝ size ＋ 4
            .如果真结束
            
        .如果真结束
        .如果真 (modrm ≥ 64 且 modrm ≤ 127 且 位与 (modrm, 7) ≠ 4)
            size ＝ size ＋ 1
        .如果真结束
        .如果真 (modrm ≥ 128 且 modrm ≤ 191 且 位与 (modrm, 7) ≠ 4)
            size ＝ size ＋ 4
        .如果真结束
        
    .如果真结束
    .如果真 (位与 (instruction, 16) ≠ 0) ' #C_DATA32
        size ＝ size ＋ 4
    .如果真结束
    .如果真 (位与 (instruction, 4) ≠ 0) ' #C_DATA8
        size ＝ size ＋ 1
    .如果真结束
    .如果真 (位与 (instruction, 8) ≠ 0) ' #C_DATA16
        size ＝ size ＋ 2
    .如果真结束
    .如果真 (instruction ＝ 0) ' #C_UNKNOWN
        size ＝ size ＋ 1
    .如果真结束
    table_1 ＝ { }
    table_2 ＝ { }
    返回 (size)
    

.子程序 暂停其他线程, 逻辑型, , 参照mHook实现安全Hook
    .局部变量 当前线程句柄, 整数型
    .局部变量 原始权限, 整数型
    .局部变量 当前进程ID, 整数型
    .局部变量 快照句柄, 整数型
    .局部变量 线程入口结构, THREADENTRY32
    .局部变量 临时布尔变量, 逻辑型
    .局部变量 挂起线程返回句柄, 整数型

    当前线程句柄 ＝ API_GetCurrentThread ()
    原始权限 ＝ API_GetThreadPriority (当前线程句柄)
    API_SetThreadPriority (当前线程句柄, 15) ' THREAD_PRIORITY_TIME_CRITICAL=15
    当前进程ID ＝ API_GetCurrentProcessId ()
    快照句柄 ＝ API_CreateToolhelp32Snapshot (4, 当前进程ID) ' TH32CS_SNAPTHREAD=4
    .如果真 (有效句柄 (快照句柄))
        线程入口结构.dwSize ＝ 28 ' 296 无法正常执行,这个值不知道是多少.7*4=28 sizeof(THREADENTRY32)
        临时布尔变量 ＝ API_Thread32First (快照句柄, 线程入口结构)
        .判断循环首 (临时布尔变量)
            ' mHook的这个地方先判断有几个线程,大于0再循环挂起线程.
            ' 然后后面貌似是检查代码执行到什么地方,不能执行到当前被Hook的位置,如果执行到,那就恢复线程(貌似是恢复所有线程).
            ' mHook的代码太多,后面晦涩难懂 - - ,不管了,就这样吧...
            .如果真 (线程入口结构.th32OwnerProcessID ＝ 当前进程ID 且 线程入口结构.th32ThreadID ≠ API_GetCurrentThreadId ())
                ' 输出调试文本 (“APIHook增强类-> 该线程可以被挂起,ID:” ＋ 到文本 (线程入口结构.th32ThreadID))
                挂起线程返回句柄 ＝ 挂起指定线程 (线程入口结构.th32ThreadID)
                .如果真 (挂起线程返回句柄 ≠ 0)
                    加入成员 (被暂停的句柄, 挂起线程返回句柄)
                    ' 输出调试文本 (“APIHook增强类-> 被成功挂起的线程句柄为:” ＋ 到文本 (挂起线程返回句柄))
                .如果真结束
                
            .如果真结束
            临时布尔变量 ＝ API_Thread32Next (快照句柄, 线程入口结构)
        .判断循环尾 ()
        API_SetThreadPriority (当前线程句柄, 原始权限)
        返回 (真)
    .如果真结束
    ' 输出调试文本 (“APIHook增强类-> 创建线程快照失败!”)
    API_SetThreadPriority (当前线程句柄, 原始权限)
    返回 (假)

.子程序 挂起指定线程, 整数型, , 参照mHook实现安全Hook
    .参数 线程ID, 整数型
    .局部变量 返回句柄, 整数型
    .局部变量 挂起结果, 整数型

    返回句柄 ＝ API_OpenThread (2032639, 假, 线程ID) ' THREAD_ALL_ACCESS=2032639
    .如果真 (有效句柄 (返回句柄))
        挂起结果 ＝ API_SuspendThread (返回句柄)
        ' API_CloseHandle (返回句柄)  ' 这里关闭句柄会出错,mHook中没有关闭这个有效的句柄,只关闭了无效的...
        返回 (返回句柄)
    .如果真结束
    API_CloseHandle (返回句柄)
    返回句柄 ＝ 0
    返回 (返回句柄)

.子程序 恢复其他线程, , , 参照mHook实现安全Hook
    .局部变量 当前线程句柄, 整数型
    .局部变量 原始权限, 整数型
    .局部变量 i, 整数型

    当前线程句柄 ＝ API_GetCurrentThread ()
    原始权限 ＝ API_GetThreadPriority (当前线程句柄)
    API_SetThreadPriority (当前线程句柄, 15) ' THREAD_PRIORITY_TIME_CRITICAL=15
    .计次循环首 (取数组成员数 (被暂停的句柄), i)
        API_ResumeThread (被暂停的句柄 [i])
        API_CloseHandle (被暂停的句柄 [i])
    .计次循环尾 ()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    清除数组 (被暂停的句柄)
    API_SetThreadPriority (当前线程句柄, 原始权限)

.子程序 有效句柄, 逻辑型, , 句柄不为0和-1
    .参数 句柄, 整数型

    .如果真 (句柄 ≠ -1 且 句柄 ≠ 0)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 汇编sizeofcode, 整数型, , 纯汇编版本获取反汇编代码长度,这是收集到的另一个长度反汇编,具体没测试,不知道是否支持诸如64位等(不知道作者是谁)
    .参数 Address, 整数型

    置入代码 ({ 86, 81, 139, 117, 8, 139, 198, 232, 136, 0, 0, 0, 139, 193, 89, 94, 201, 194, 4, 0, 85, 85, 52, 153, 85, 85, 52, 145, 85, 85, 52, 153, 85, 85, 52, 153, 85, 85, 52, 146, 85, 85, 52, 146, 85, 85, 52, 146, 85, 85, 52, 146, 34, 34, 34, 34, 34, 34, 34, 34, 170, 170, 170, 170, 170, 170, 170, 170, 170, 153, 9, 9, 199, 182, 153, 153, 136, 136, 136, 136, 136, 136, 136, 136, 103, 102, 85, 221, 221, 221, 157, 145, 10, 170, 170, 170, 170, 153, 153, 153, 204, 204, 170, 34, 52, 170, 170, 34, 187, 187, 187, 187, 204, 204, 204, 204, 102, 154, 153, 17, 154, 153, 153, 153, 85, 85, 51, 153, 153, 153, 153, 153, 136, 136, 153, 153, 136, 152, 153, 153, 153, 0, 146, 17, 34, 153, 34, 17, 82, 86, 150, 51, 210, 172, 15, 182, 200, 81, 209, 233, 232, 0, 0, 0, 0, 88, 138, 132, 1, 111, 255, 255, 255, 114, 3, 192, 232, 4, 89, 131, 224, 15, 117, 36, 145, 60, 102, 114, 7, 116, 4, 44, 241, 3, 200, 65, 65, 15, 187, 202, 115, 207, 235, 12, 145, 70, 70, 60, 195, 116, 90, 70, 60, 200, 116, 85, 94, 90, 249, 195, 44, 2, 120, 91, 36, 7, 44, 3, 114, 56, 44, 3, 114, 15, 117, 224, 145, 44, 232, 60, 2, 114, 69, 172, 15, 190, 192, 235, 55, 80, 172, 138, 224, 36, 7, 128, 228, 192, 116, 13, 128, 252, 128, 119, 20, 114, 3, 131, 198, 3, 70, 235, 7, 60, 5, 117, 3, 131, 198, 4, 60, 4, 117, 1, 70, 88, 60, 254, 116, 10, 114, 9, 246, 194, 4, 117, 2, 70, 70, 70, 70, 131, 200, 255, 139, 206, 94, 43, 206, 90, 248, 195, 173, 235, 245, 145, 60, 247, 119, 67, 60, 15, 116, 28, 60, 246, 114, 11, 44, 248, 246, 6, 56, 116, 170, 176, 253, 235, 166, 246, 6, 56, 117, 38, 44, 200, 60, 254, 119, 155, 235, 239, 172, 87, 232, 5, 0, 0, 0, 175, 182, 183, 190, 191, 95, 177, 5, 242, 174, 95, 116, 219, 44, 128, 60, 16, 114, 190, 60, 32, 114, 209, 233, 85, 255, 255, 255, 246, 6, 48, 116, 199, 60, 254, 116, 242, 246, 6, 8, 116, 190, 235, 235 })
    返回 (-1)

